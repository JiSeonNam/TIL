# 인터페이스(Interface) - 기본 설계도
상속(Inheritance) 관계에 얽매이지 않고, 해당 인터페이스를 구현하는 클래스들에 대해 동일한 목적하에 동일한 기능을 보장하기 위해 만들어졌다. 추상클래스는 상속에 의해서만 구현가능하다. 
즉, 바꿔말하면 상속이 아니고서는 구현할 수가 없다. <br>
일반적으로 인터페이스는 클래스로부터 구현(Implements)하여 사용해야하기 때문에, 클래스에서 오버라이딩하여 사용한다. 
이로 인해, 구현부를 직접 연결하지 않는 약한결합을 가지게 된다. 
만약 다른 추상클래스를 상속하는 클래스들의 공통기능을 명시하고자 하면 인터페이스를 사용하여 구현하면 편리할 것이다.<br>
인터페이스는 기본 설계도만 있고 클래스로 구현해서 사용하기 때문에 구현부 내용을 바꿔도 상관없이 이용이 가능하다. 
이러한 인터페이스는 두 대상(객체) 간의 '연결, 대화, 소통'을 돕는 '중간 역할'을 의미한다. <br>
인터페이스는 인터페이스로부터만 상속을 받을 수 있으며, 클래스와 달리 다중상속이 가능하다. 
인터페이스는 Object클래스와 같은 최고조상이 없다.

```
interface 인터페이스이름 {
    public static final 타입 상수이름 = 값; //상수
    타입 상수이름 = 값; //public static final 생략가능(예외가 없기때문에)
    public abstract 메서드이름(매개변수목록); //추상메서드
    메서드이름(매개변수목록); //public abstract 생략가능(예외가 없기때문에)
}

class 클래스이름 implements 인터페이스이름{
	//인터페이스에 정의된 추상메서드를 모두 구현해야 한다
}
```

### 종류
- 상수필드(public static final)
- 추상메소드(public abstract method)
- 디폴트메소드(public default method)
- 정적메소드(public static method)

### 인터페이스를 이용한 다형성(polymorphism)
인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있으며, 인터페이스 타입으로의 형변환도 가능하다. 
주의점은 참조변수가 가리키고 있는 객체가 인터페이스에 없는 다른 메소드를 포함하고 있을지라도, 인터페이스에 정의되어 있는 메소드만을 호출할 수 있다.

```
//Fightable : 인터페이스, Fighter : 클래스, f : 인스턴스
Fightable f = (Fightable)new Fighter();
Fightable f = new Fighter();

void attack(Fightable f){}

class Fighter extends Unit implements Fightable{ //인터페이스를 구현한 클래스
	public void move(int x, int y){}
	public void attack(Fightable f) //인터페이스의 인스턴스를 넘겨준다
}
```

인터페이스의 인스턴스를 넘겨준다는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미한다.
<br><br>

# 추상클래스(Abstract class) - 미완성 설계도
동일한 부모를 가지는 클래스를 묶는 개념으로 상속(extends)을 통해 기능을 이용하고 확장시키기 위해 만들어졌다. 
즉, 여러 클래스에서 공통적으로 사용될 수 있는 추상클래스의 공통 부문을 뽑아 추상클래스로 만든 뒤, 이를 상속받아 사용하는 방법이다.<br>
추상클래스에는 추상메서드를 가지고 있으므로, 일반클래스에서 추상클래스를 상속받아 추상메서드를 구현하여 사용한다. 
추상클래스는 미완성의 메서드를 가지고 있으므로, 구현부가 없어 자식마다 다르게 구현이 가능하다. 
이는 곧, 추상클래스를 구현할 때 선언부만 가지고도 구현이 가능하다는 것을 의미한다. <br>
추상클래스를 상속받았을 때, 인터페이스와 달리 모든 추상메서드를 구현하지 않아도 된다. 
이 때문에 인터페이스와는 다른 목적을 가졌다는 것을 알 수 있다. 인터페이스를 구현한 클래스는 모두 동일한 목적하에 동일한 기능을 수행해야 하므로 모든 추상메서드를 구현해야하기 때문이다. 
만약, 추상클래스에서 일부분의 추상메서드만 구현하고 싶을 경우에는 클래스 앞에 abstract를 명시하여 아직 구현되지 않은 추상메서드가 있음을 알려야 한다.

```
abstract class 추상클래스이름 {
    …
	public abstract void 메서드이름(매개변수목록);
	public abstract void 메서드이름();
}

class 클래스이름 extends 추상클래스이름{
	void 메서드이름(매개변수목록){}
	void 메서드이름(){}
}
```
