# 자바 언어
Java 프로그래밍 언어에서 모든 소스 코드는 .java 으로 끝나는 일반 텍스트 파일로 저장된다. .java 파일은 1차적으로 javac(자바시) 컴파일러에 의해 .class 파일로 컴파일된다. 이후, 2차적으로 JVM(Java Virtual Machine)에 의해 운영체제에 작용하는 기계어로 컴파일되어 Java 프로그램이 실행된다. JVM 때문에 .class 파일은 어느 운영체제에서 사용이 가능하다. 
ByteCode란 사용자가 작성한 .java 소스코드파일을 JVM이 운영체제에 실행가능한 명령어 집합파일로 컴파일하는 과정 중에 필요한 코드를 의미한다. 

![getStarted-compiler](https://user-images.githubusercontent.com/71870567/108070845-55216280-70a8-11eb-88a9-6fcfd9b7f24a.gif)

![helloWorld](https://user-images.githubusercontent.com/71870567/108070886-64081500-70a8-11eb-8143-e808a91bfcc7.gif)
<br><br>

# 자바 플랫폼
플랫폼은 프로그램이 실행되는 하드웨어 또는 소프트웨어 환경을 의미한다. 일반적인 플랫폼은 하드웨어 기반 위에서 실행되는 소프트웨어 기반 플랫폼 인 것과 달리 자바 플랫폼은 이와는 달리 두 가지 구성요소가 있다.

- JVM(Java Virtual Machine) : 자바에서 명령을 실행하는 일련의 소프트웨어 프로그램으로 일반적으로 Java ByteCode로 작성된다. 일반적인 애플리케이션은 OS(운영체제)와 직접적으로 연관되어 전달되는데 비해, Java는 JVM을 거쳐서 컴파일되기 때문에 운영체제에 상관없이 사용할 수 있다.
- API(Java Application Programming Interface)

여기서 API는 유용한 기능을 제공하는 소프트웨어 구성요소의 대규모 컬렉션이라고 볼 수 있다. 이는 class와 interface 라이브러리로 그룹화되어있다. 

![getStarted-jvm](https://user-images.githubusercontent.com/71870567/108071036-91ed5980-70a8-11eb-9c00-a7d799402408.gif)
<br><br>

# 객체(Object)
현실세계에서 상태(state)와 행동(behavior)에 빗대어 생각해 볼 수 있다. 객체는 필드(field)에 상태를 저장하고, 메소드(method)에 행동을 노출한다. 
메소드는 객체 내부에서 객체와 객체간의 주요 커뮤니케이션 역할을 한다.

![concepts-object](https://user-images.githubusercontent.com/71870567/108071569-3a032280-70a9-11eb-8aad-c1339f1fa110.gif)

개별 소프트웨어 객체에 코드를 번들링하면 여러가지 이점을 얻을 수 있다.
1. Modularity(모듈리티) : 객체 소스코드는 다른 객체 소스코드와 독립적으로 작성 및 유지될 수 있다. 일단 생성하면, 객체는 시스템 내부를 쉽게 통과할 수 있다.
2. Information-hiding(정보숨기기) : 객체의 메소드로만 상호작용하게 되므로, 바깥에서 내부 구현 세부사항을 숨길 수 있다.
3. Code re-use(코드 재사용) : 만약 이미 존재하는 객체가 있다면 사용할 수 있다. 이를 통해 복잡한 작업별 개체를 구현, 테스트, 디버그 할 수 있으며, 자신의 코드로 실행할 수 있따.
4. Pluggability and debugging ease(플러그 가능성 및 디버깅 용이성) : 만약 특정 객체가 문제가 있는 것으로 판단된다면, 해당 객체를 제거하고 다른 객체로 교체할 때 플러그를 꽂을 수 있다. 이것은 현실세계와 비슷하게 볼트가 부러질 경우 전체 기계를 고치는 것이 아니라 볼트를 교체하는 것과 같다.
<br><br>

# 클래스(Class)
객체지향적인 관점에서, 클래스는 개별 객체가 생성되는 청사진(blueprint)을 의미한다. 
즉, 서로 관련된 변수들을 정의하고 이들에 대한 작업을 수행하는 메소드를 함께 정의한 것을 클래스라 일컫는다.
<br><br>


# 인터페이스(Interface) - 기본 설계도
상속(Inheritance) 관계에 얽매이지 않고, 해당 인터페이스를 구현하는 클래스들에 대해 동일한 목적하에 동일한 기능을 보장하기 위해 만들어졌다. 추상클래스는 상속에 의해서만 구현가능하다. 
즉, 바꿔말하면 상속이 아니고서는 구현할 수가 없다. <br>
일반적으로 인터페이스는 클래스로부터 구현(Implements)하여 사용해야하기 때문에, 클래스에서 오버라이딩하여 사용한다. 
이로 인해, 구현부를 직접 연결하지 않는 약한결합을 가지게 된다. 
만약 다른 추상클래스를 상속하는 클래스들의 공통기능을 명시하고자 하면 인터페이스를 사용하여 구현하면 편리할 것이다.<br>
인터페이스는 기본 설계도만 있고 클래스로 구현해서 사용하기 때문에 구현부 내용을 바꿔도 상관없이 이용이 가능하다. 
이러한 인터페이스는 두 대상(객체) 간의 '연결, 대화, 소통'을 돕는 '중간 역할'을 의미한다. <br>
인터페이스는 인터페이스로부터만 상속을 받을 수 있으며, 클래스와 달리 다중상속이 가능하다. 
인터페이스는 Object클래스와 같은 최고조상이 없다.

```
interface 인터페이스이름 {
    public static final 타입 상수이름 = 값; //상수
    타입 상수이름 = 값; //public static final 생략가능(예외가 없기때문에)
    public abstract 메서드이름(매개변수목록); //추상메서드
    메서드이름(매개변수목록); //public abstract 생략가능(예외가 없기때문에)
}

class 클래스이름 implements 인터페이스이름{
	//인터페이스에 정의된 추상메서드를 모두 구현해야 한다
}
```

### 종류
- 상수필드(public static final)
- 추상메소드(public abstract method)
- 디폴트메소드(public default method)
- 정적메소드(public static method)

### 인터페이스를 이용한 다형성(polymorphism)
인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있으며, 인터페이스 타입으로의 형변환도 가능하다. 
주의점은 참조변수가 가리키고 있는 객체가 인터페이스에 없는 다른 메소드를 포함하고 있을지라도, 인터페이스에 정의되어 있는 메소드만을 호출할 수 있다.

```
//Fightable : 인터페이스, Fighter : 클래스, f : 인스턴스
Fightable f = (Fightable)new Fighter();
Fightable f = new Fighter();

void attack(Fightable f){}

class Fighter extends Unit implements Fightable{ //인터페이스를 구현한 클래스
	public void move(int x, int y){}
	public void attack(Fightable f) //인터페이스의 인스턴스를 넘겨준다
}
```

인터페이스의 인스턴스를 넘겨준다는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미한다.
<br><br>

# 추상클래스(Abstract class) - 미완성 설계도
동일한 부모를 가지는 클래스를 묶는 개념으로 상속(extends)을 통해 기능을 이용하고 확장시키기 위해 만들어졌다. 
즉, 여러 클래스에서 공통적으로 사용될 수 있는 추상클래스의 공통 부문을 뽑아 추상클래스로 만든 뒤, 이를 상속받아 사용하는 방법이다.<br>
추상클래스에는 추상메서드를 가지고 있으므로, 일반클래스에서 추상클래스를 상속받아 추상메서드를 구현하여 사용한다. 
추상클래스는 미완성의 메서드를 가지고 있으므로, 구현부가 없어 자식마다 다르게 구현이 가능하다. 
이는 곧, 추상클래스를 구현할 때 선언부만 가지고도 구현이 가능하다는 것을 의미한다. <br>
추상클래스를 상속받았을 때, 인터페이스와 달리 모든 추상메서드를 구현하지 않아도 된다. 
이 때문에 인터페이스와는 다른 목적을 가졌다는 것을 알 수 있다. 인터페이스를 구현한 클래스는 모두 동일한 목적하에 동일한 기능을 수행해야 하므로 모든 추상메서드를 구현해야하기 때문이다. 
만약, 추상클래스에서 일부분의 추상메서드만 구현하고 싶을 경우에는 클래스 앞에 abstract를 명시하여 아직 구현되지 않은 추상메서드가 있음을 알려야 한다.

```
abstract class 추상클래스이름 {
    …
	public abstract void 메서드이름(매개변수목록);
	public abstract void 메서드이름();
}

class 클래스이름 extends 추상클래스이름{
	void 메서드이름(매개변수목록){}
	void 메서드이름(){}
}
```











